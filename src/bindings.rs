/* automatically generated by rust-bindgen 0.69.4 */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 0;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const GRE_IO_TYPE_RDONLY: u32 = 0;
pub const GRE_IO_TYPE_XRDONLY: u32 = 1;
pub const GRE_IO_TYPE_WRONLY: u32 = 2;
pub const GRE_IO_TYPE_MASK: u32 = 15;
pub const GRE_IO_FLAG_NONBLOCK: u32 = 16;
pub const GRE_IO_FLAG_MASK: u32 = 65520;
pub const GRE_IO_MAX_NAME_LEN: u32 = 25;
pub const GRE_IO_MAX_MSG_UNLIMITED: u32 = 0;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_uint;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_int;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub const gre_io_error_codes_GREIO_ERROR_NO_ERROR: gre_io_error_codes = 0;
pub const gre_io_error_codes_GREIO_ERROR_UNKNOWN: gre_io_error_codes = 1;
pub const gre_io_error_codes_GREIO_ERROR_OUT_OF_MEMORY: gre_io_error_codes = 2;
pub const gre_io_error_codes_GREIO_ERROR_ACCESS: gre_io_error_codes = 3;
pub const gre_io_error_codes_GREIO_ERROR_QUEUE_EMPTY: gre_io_error_codes = 4;
pub const gre_io_error_codes_GREIO_ERROR_QUEUE_FULL: gre_io_error_codes = 5;
pub const gre_io_error_codes_GREIO_ERROR_TIMEOUT: gre_io_error_codes = 6;
pub const gre_io_error_codes_GREIO_ERROR_LAST_CODE: gre_io_error_codes = 7;
pub type gre_io_error_codes = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gre_io_ {
    _unused: [u8; 0],
}
#[doc = " Opaque handle for IO operations."]
pub type gre_io_t = _gre_io_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gre_io_serialized_data {
    #[doc = "< Serialized buffer data"]
    pub buffer: *mut ::std::os::raw::c_char,
    #[doc = "< Number of bytes allocated for the buffer (capacity)"]
    pub buffer_nbytes: ::std::os::raw::c_int,
    #[doc = "< Number of bytes the data is occupying (size)"]
    pub data_nbytes: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__gre_io_serialized_data() {
    const UNINIT: ::std::mem::MaybeUninit<_gre_io_serialized_data> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_gre_io_serialized_data>(),
        16usize,
        concat!("Size of: ", stringify!(_gre_io_serialized_data))
    );
    assert_eq!(
        ::std::mem::align_of::<_gre_io_serialized_data>(),
        8usize,
        concat!("Alignment of ", stringify!(_gre_io_serialized_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gre_io_serialized_data),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer_nbytes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_gre_io_serialized_data),
            "::",
            stringify!(buffer_nbytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_nbytes) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_gre_io_serialized_data),
            "::",
            stringify!(data_nbytes)
        )
    );
}
pub type gre_io_serialized_data_t = _gre_io_serialized_data;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _multi_data_set {
    pub size: u16,
    pub data_offset: u16,
    pub data_size: u32,
    pub format: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__multi_data_set() {
    const UNINIT: ::std::mem::MaybeUninit<_multi_data_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_multi_data_set>(),
        16usize,
        concat!("Size of: ", stringify!(_multi_data_set))
    );
    assert_eq!(
        ::std::mem::align_of::<_multi_data_set>(),
        4usize,
        concat!("Alignment of ", stringify!(_multi_data_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_multi_data_set),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_offset) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_multi_data_set),
            "::",
            stringify!(data_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_multi_data_set),
            "::",
            stringify!(data_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_multi_data_set),
            "::",
            stringify!(format)
        )
    );
}
pub type gre_io_mdata_t = _multi_data_set;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gre_io_error {
    pub error_code: i32,
    pub sys_code: i32,
}
#[test]
fn bindgen_test_layout__gre_io_error() {
    const UNINIT: ::std::mem::MaybeUninit<_gre_io_error> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_gre_io_error>(),
        8usize,
        concat!("Size of: ", stringify!(_gre_io_error))
    );
    assert_eq!(
        ::std::mem::align_of::<_gre_io_error>(),
        4usize,
        concat!("Alignment of ", stringify!(_gre_io_error))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_code) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gre_io_error),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sys_code) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_gre_io_error),
            "::",
            stringify!(sys_code)
        )
    );
}
pub type gre_io_error_t = _gre_io_error;
extern "C" {
    #[doc = " Open an IO connection using a named connection.\n\n @param io_name The name of the io-channel to use\n @param flag The mode you want to open the queue in\n @return handle to greio channel or NULL on failure."]
    pub fn gre_io_open(
        io_name: *const ::std::os::raw::c_char,
        flag: ::std::os::raw::c_int,
        ...
    ) -> *mut gre_io_t;
}
extern "C" {
    #[doc = " Close an io connection.  Any pending clients will return\n\n with an error on their action.\n @param handle A valid handle created with gre_io_open()"]
    pub fn gre_io_close(handle: *mut gre_io_t);
}
extern "C" {
    #[doc = " Send a serialized buffer to the handle.\n @param handle A valid handle created with gre_io_open()\n @param buffer A data buffer containing a serialized event\n @return -1 on failure anything else is success"]
    pub fn gre_io_send(
        handle: *mut gre_io_t,
        buffer: *mut gre_io_serialized_data_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Receive a serialized event.  This call blocks until an event is received\n or until the channel is destroyed.\n\n @param handle A valid handle created with gre_io_open()\n @param buffer A pointer to a serialized buffer pointer.  If the\n  buffer is NULL then a new buffer is allocated otherwise the buffer\n  provided is used to store the received event.\n @return The size of the message received or -1 on failure"]
    pub fn gre_io_receive(
        handle: *mut gre_io_t,
        buffer: *mut *mut gre_io_serialized_data_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the max message size that may be sent over an IO channel to match the size specified by the provided serialized buffer.\n This is not available on all greio implementations and will fail by returning -1 if it is not supported.\n\n @param handle A valid handle created with gre_io_open()\n @param buffer A data buffer\n @return -1 on failure anything else is success"]
    pub fn gre_io_grow_buffer(
        handle: *mut gre_io_t,
        buffer: *mut gre_io_serialized_data_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the maximum size of a message that may be sent over IO channel.\n\n @param handle A valid handle created with gre_io_open()\n @return -1 on error, success the size in bytes"]
    pub fn gre_io_max_message(handle: *mut gre_io_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the error codes if greio experiences an error.\n\n @param handle A valid handle created with gre_io_open()\n @param errorcodes A valid gre_io_error_t structure to be filled out"]
    pub fn gre_io_get_error_codes(handle: *mut gre_io_t, errorcodes: *mut gre_io_error_t);
}
extern "C" {
    #[doc = " Get the error message for an error code returned by a call to gre_io_get_error_codes.\n\n @param errorcodes A valid gre_io_error_t structure containing the errors returned\n  from a call to gre_io_get_error_codes\n @return The error message"]
    pub fn gre_io_get_error_message(
        errorcodes: *mut gre_io_error_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " This creates a data buffer to hold the serialized event data required\n for transmission.  This allows a resizable buffer to be allocated once\n and then re-used for multiple event transmissions.\n\n If the provided buffer is not NULL and already contains data within\n its buffers, then the resizing of the buffer will transfer the contents\n of the old internal buffer to the new buffer, similar to the realloc()\n function.  The buffer may be used in this fashion when data is being\n streamed so that multiple buffers are not required.\n\n Callers passing in a buffer should ensure that the return value is non-NULL before overwriting the\n pointer.  This is the same pattern that should be used when calling realloc.\n\n gre_io_serialized_data_t *new_buffer;\n new_buffer = gre_io_serialize(buffer, target, name, format, data, nbytes);\n if (!new_buffer) {\n     gre_io_free_buffer(buffer);\n     //log error.\n     return;\n }\n buffer = new_buffer;\n\n @param buffer The buffer to be sized, or NULL to allocate a new buffer\n @param nbytes The number of bytes this buffer should be able to support\n @return A buffer with room for a message nbytes in size or NULL if no space available"]
    pub fn gre_io_size_buffer(
        buffer: *mut gre_io_serialized_data_t,
        nbytes: ::std::os::raw::c_int,
    ) -> *mut gre_io_serialized_data_t;
}
extern "C" {
    #[doc = " This sets the data payload of the buffer to zero (0) bytes.\n The buffer is not resized or free'ed, but data content in\n the buffer should be considered lost.\n\n @param buffer The buffer to be de-allocated"]
    pub fn gre_io_zero_buffer(buffer: *mut gre_io_serialized_data_t);
}
extern "C" {
    #[doc = " This de-allocates a buffer that has been allocated through the\n calls to gre_io_* functions.\n\n @param buffer The buffer to be de-allocated"]
    pub fn gre_io_free_buffer(buffer: *mut gre_io_serialized_data_t);
}
extern "C" {
    #[doc = " Transform event data elements (see <io_mgr.h>) into a serialized data buffer.\n\n @param buffer The buffer that will contain the serialized data or NULL if a new buffer should be allocated\n @param event_target The name of the event target, or NULL to send to the default target\n @param event_name The name of the event to send, or NULL to send an empty event\n @param event_format The format of the data (see <data_format.h>, or NULL if no data is being sent\n @param event_data A pointer do the data to transmit, or NULL if no data is transmitted\n @param event_nbytes The number of data bytes to transmit, or NULL if no data is transmitted\n @return A buffer with the serialized data or NULL on error (errno is set)"]
    pub fn gre_io_serialize(
        buffer: *mut gre_io_serialized_data_t,
        event_target: *const ::std::os::raw::c_char,
        event_name: *const ::std::os::raw::c_char,
        event_format: *const ::std::os::raw::c_char,
        event_data: *const ::std::os::raw::c_void,
        event_nbytes: ::std::os::raw::c_int,
    ) -> *mut gre_io_serialized_data_t;
}
extern "C" {
    #[doc = " Transform a serialized buffer into event data elements (see <io_mgr.h>).  The\n pointers returned point back into the content of the serialized buffer so the\n buffer can't be de-allocated until clients are finished manipulating the data\n elements.\n\n @param buffer The buffer containing the serialized data\n @param event_target Location to store the event target\n @param event_name Location to store the event name\n @param event_format  Location to store the event format\n @param event_data  Location to store the event data\n @return The number of bytes in the event_data structure"]
    pub fn gre_io_unserialize(
        buffer: *mut gre_io_serialized_data_t,
        event_target: *mut *mut ::std::os::raw::c_char,
        event_name: *mut *mut ::std::os::raw::c_char,
        event_format: *mut *mut ::std::os::raw::c_char,
        event_data: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a data key/value pair to a serialized buffer.\n This call can be used to add serialize multiple data\n sets into a single send. This buffer can be later sent via\n the gre_io_send_mdata call.\n\n @param mbuffer The buffer containing the serialized data\n @param key_name Name of the variable to be set in data manager\n @param data_format The format of the data (see <data_format.h>, or NULL if no data is being sent\n @param data  A pointer do the data to transmit\n @param data_nbytes  The number of data bytes to transmit, or NULL if no data is transmitted\n @return -1 on failure anything else is success"]
    pub fn gre_io_add_mdata(
        mbuffer: *mut *mut gre_io_serialized_data_t,
        key_name: *const ::std::os::raw::c_char,
        data_format: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_void,
        data_nbytes: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Send a serialized buffer of mdata (data manager key/value pairs) to the handle.\n\n @param handle A valid handle created with gre_io_open()\n @param md_buffer A data buffer containing a serialized event\n @return -1 on failure anything else is success"]
    pub fn gre_io_send_mdata(
        handle: *mut gre_io_t,
        md_buffer: *mut gre_io_serialized_data_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert an array of parsable string segments (ie [0]4s1:value [1]20 [3]1s0:name [4]Crank ...)\n into a memory block and event format string.  Clients are responsible for the memory\n associated with the returned format string and the event data and should call free() to\n deallocated it when they are finished.\n\n @param argv  A pointer to format/value segments\n @param argc  The number of segments in argv\n @param event_data   A pointer to a pointer where the event data can be stored.\n @param event_data_nbytes   The number of bytes of data event_data points at\n @return A format string describing the memory block or NULL on failure"]
    pub fn greio_array_to_event_data(
        argv: *mut *mut ::std::os::raw::c_char,
        argc: ::std::os::raw::c_int,
        event_data: *mut *mut ::std::os::raw::c_void,
        event_data_nbytes: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Convert a parsable data string to a memory block and event format string. Clients are\n responsible for the memory associated with the returned format string and the event\n data and should call free() to deallocated it when they are finished.\n\n @param data_string  A non-nul data and format string (from greio_event_data_to_string)\n @param event_data   A pointer to a pointer where the event data can be stored.\n @param event_data_nbytes   The number of bytes of data event_data points at\n @return A format string describing the memory block or NULL on failure"]
    pub fn greio_string_to_event_data(
        data_string: *mut ::std::os::raw::c_char,
        event_data: *mut *mut ::std::os::raw::c_void,
        event_data_nbytes: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Convert an user data event payload to a parseable data string.  Client are expected to\n expect a NULL return code if the format string or data is empty. Clients are responsible for\n the memory associated with the string returned and should call free() to deallocate it.\n\n @param event_format \tA nul terminated string that contains a standard format string\n @param event_data    A pointer to a block of memory to be interpreted via event_format\n @param event_data_nbytes The number of bytes that event_data points to\n @return An allocated string parsable via greio_string_to_event_data or NULL on failure"]
    pub fn greio_event_data_to_string(
        event_format: *mut ::std::os::raw::c_char,
        event_data: *mut ::std::os::raw::c_void,
        event_data_nbytes: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
